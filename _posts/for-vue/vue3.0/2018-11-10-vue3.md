---
layout: post
title: vue props
date: Sat Nov 10 2018 20:16:33 GMT+0800
---
#### vue3.0
1. 更快
	- virtual DOM实现重构，优化编译减少运行时开销
	- 优化slots的生成
	- 静态内容的提取
2. 更好（基于Proxy的新数据监听系统，全语言特性支持 + 更好的性能）
	- 对象属性增添 / 删除
	- 数组index / length更改
	- Map,Set,WeakMap,WeakSet
	- Classes
3. 更小
	- vue本身的runtime可以变得更小



**virtual DOM实现重构，优化编译减少运行时开销**
virtual dom在运行时有很多潜在开销，比如说在模板里有很多不会变动的地方，但虚拟dom会重新生成这些节点，然后对这些节点进行比对，其实这些操作在很多情况下其实不必要，因此可以在编译时对模板进行分析，来减少这些运行时的开销。vue2.x有一定程度的优化，但3.0更彻底

当将模板编译为虚拟dom的渲染函数时，在vue2.0里不管是原生组件还是浏览器自带的html的元素，都是统一作为一个字符串传递给h函数（就是创建一个虚拟node的一个函数）里，然后判断一个元素到底是组件还是原生元素的时候，其实是在运行时来做的。这里就有不可避免有些开销，因为都需要先判断一下是组件还是原生元素。而3.0则在编译时进行判断，如果一定是一个html原生元素的话，那我们在运行时就直接生成原生元素对应的虚拟dom的代码。同样，如果是组件，就生成组件的代码。这就是所谓的Component fast Path ，还有就是尽可能生成所谓的叫Monomorphic calls，即使在生成这些虚拟node的时候，我们的函数调用要尽可能的形状一致，也就是它有同样个数的参数。这样对于我们生成的代码，更易于被js引擎来优化，这些就是一些比较底层的优化技巧。

最后还可以做，在模板中直接静态的分析一个元素所包含的子元素的类型，比如下面代码，我们在div里有一个span标签，这时就可以在生成的代码里面，给运行时留下一些类似于hint(就是一些提示)，比如这里是一个元素，然后就可以在算法里，直接跳入对应只有一个子元素的这个分支。就可以跳过很多其他不必要的判断，这些积少成多的优化，就可以在整个应用产生很客观的收益
```html
<div>
	<span></span>
</div>
```

**优化slots的生成**
之前我们使用slots时，一般先在父组件里定义一个slot，然后会自动传入到子组件。但当这个slot在父组件内变化后，会先在父组件里更新完毕，然后才会传入子组件，也就是每次都需要更新两个组件，也就是父子关联更新。在
新的生成机制里，我们将所有的slot都跟scope slot一样统一生成为一个函数，这个函数可以认为是一个lazy的函数，当你把函数传给子组件之后，由子组件来决定什么时候来调用这个函数，当子组件调用这个函数的时候，这个slot的依赖就成为了子组件而不是父组件的，这时当依赖变动的时候，只需要重新渲染子组件，然后父子的依赖就彻底的分开。这样再整个应用中就会得到一个非常精确的组件级的依赖收集，进而可以进一步的避免不必要的组件渲染。到这里，就基本可以说vue的更新检测就可以说是完全精确的了，也就是任何组件当其真正的依赖变化时才会更新，就不存在需要手动优化组件过度重绘这个问题了

**静态内容的提取**
这个其实在2.0里已经做了，就是当我们检测到一部分的模板是不变的，直接可以把它提取出来，那么在之后的更新中，这一部分模板不仅可以直接复用之前的虚拟DOM，连比对过程都可以直接整个树就直接跳过。但2.0里没有做的是，当一个元素它内部任意深度包含任意动态内容的时候，那整个元素就无法被静态化，那这就很可惜，但是还可以做一些优化，那就是如果这个元素本身上面所有的属性都是静态的，那就可以把这个属性对象给提取出来，提取之后，然后我们比对这个元素的时候，发现这个元素它的所有的data都是一样的，那这个元素本身就不需要比对了。然后就可以直接去比对他们的children就可以了。

还有内联事件函数提取，比如`<Comp @event="count++">`其实就是一个内联的函数，也就是每次重新渲染的时候都会生成一个新的函数，由于这个新的函数和之前的函数时不一样的，虽然做的事情是一样的，但对于js来说无法区分，因此为了安全起见，会导致这个子组件每次都重新渲染，通过一定程度的优化，就是我们把它生成一次之后，就把它给cache，之后每次都复用同一个函数，这样就可以避免子组件无谓更新的一个效果。


以上就是关于模板编译以及虚拟dom运行时性能方面的优化


**数据监听系统**
在2.0里面，用的是ES5的getter及setter，也就是`Object.defineProperty`这个api，在3.0里我们会基于proxy来实现一个全新的数据监听系统。这个已经实现在我们的Prototype里面了，还实现了全语言特性支持，同时还有更好的特性，全语言特性支持意味着，对新属性的增加、删除，数组的index/length，Map,Set,WeakMap,WeakSet及Classes等都能完美支持。同时在应用初始化时候，侦听大规模数据的时候，性能也会得到提升。事实上基于proxy的数据侦听系统，是所谓的lazy by default，就是只有当一个数据被用到的时候，我们才会使用它，如果对于一个大数据，但是只使用了其中的一部分，那其实我们只会监听其中的一小部分，这也是另一方面的一个性能优化。

**利用proxy还可以减少组件实例初始化开销**
我们知道每个vue组件都会代理它所包含的，包括所有的data，computed以及props，这些代理都是通过`Object.defineProperty`来实现的。在实际的实例生成中，其实大量的`Object.defineProperty`是一个相对昂贵的一个操作。在3.0里，我们直接暴露给用户的这个this,其实是一个真正的组件实例的一个proxy，然后当你在这个proxy上获取一些属性的时候，我们内部再做判断，这样就彻底的避免了`Object.defineProperty`使用。然后实测下来也是对组件实例化、初始化，实例的初始化带来了很高的性能提升，所以实例及组件的初始化也快了近一倍。所有这些初始化最终达到的一个大概的效果就是，**速度加倍，内存占用减半**。这些改动都不涉及上层api的改动，也就是说使用3.0,还是之前的api就可以达到这个性能。


**vue本身的runtime可以变得更小**
现在vue代码运行时也就是20k左右，为了做到更小，就是让我们的整个代码结构可以和tree-shaking（可以在最后编译的时候给它扔掉）配合起来。之前vue的代码，一个vue对象进来，然后所有的东西都在这个vue对象上，这样的话其实所有你没有用到的东西，也没有办法扔掉，因为他们都被增添到vue这个全局对象上了。但在3.0里面，一些不是每个应用都需要的功能，就做成了按需引入，用ES module import按需引入，比如内置组件keep-alive，transition等,以及指令的配合的运行时，比如v-model,v-for，需要的一些helper的函数，各种的工具函数，比如说创建一个async component、使用mixins,或者是memoize(这是一个新的内部工具函数)，很多时候这些工具函数，都可以做成按需引入。

还有很多指令的运行时，在我们编译的时候，就可以生成对应的代码。也就是说当你使用了v-model的时候，我们才会去miport v-model相关的代码。这就保证了当你使用最基本的功能时，你就只会用到最核心的任何vue应用都会用到的那一部分代码。这样总的效果就是最终vue运行时的代码在10k左右，这样在之前速度加倍，内存减半后，这里还是可以尺寸减半（就是代码大小减半）。


**更易于维护**
其实是针对vue的开发团队而言的，这对于想要阅读源码及参与进来的开发人员来说，也是一件有意义的事情。


**Flow -> TypeScript**
代码从Flow迁徙到ts,我们是用ts完全重写了。flow这个项目，说实话facebook维护的不怎么样。ts则更加友好。所以以后全部改用ts，所以以后对ts的支持会越来越好。。。

**内部模块解耦**
对于2.0的源码其实是不太好理解的，但到了3.0,因为用到了ts，本身这些声明的类型就有助于理解源码。因此对于阅读源码的人来说更友好。
另外就是在内部的模块进行清晰的解耦，也就是说解耦后的模板是相对独立的，是可以单独使用的，因此只需要每个模块每个模块的阅读源码就好，每个模块内部还有文档及单元测试。然后就可以直接提出PR或改动，而不用担心影响到其他模块。这也是出于让更多的人参与到vue源码开发的目的的。

Evan You（尤雨溪）今天（2018年11月16日）早上在 Vue Toronto 的主题演讲中预演了 Vue 3 。利用现代浏览器支持的新功能，Vue 3 将成为我们已经了解和喜爱的 Vue.js 强大的的改进版本。我们做了一些笔记并将其与下面的幻灯片结合起来分享给大家。

总结起来，Vue 3 以下方面值得我们期待 ：

更快
更小
更易于维护
更多的原生支持
更易于开发使用
[完整的PPT](https://docs.google.com/presentation/d/1yhPGyhQrJcpJI2ZFvBme3pGKaGNiLi709c37svivv0o/edit#slide=id.p)

Evan 和 Vue 团队的目标是尽可能顺利地过渡到 Vue 3 ，在这个过程中，这些变化在无形地改善了框架。

让 Vue 更快
虽然 Vue 已经非常快了，但 Evan 认为 Vue 3 会更快。如何做到呢…

重写虚拟DOM (Virtual DOM Rewrite)
随着虚拟 DOM 重写，我们可以期待更多的 编译时（compile-time）提示来减少 运行时（runtime）开销。重写将包括更有效的代码来创建虚拟节点。

在这里插入图片描述

优化插槽生成(Optimized Slots Generation)
在当前的 Vue 版本中，当父组件重新渲染时，其子组件也必须重新渲染。 使用 Vue 3 ，可以单独重新渲染父组件和子组件。

在这里插入图片描述

静态树提升(Static Tree Hoisting)
使用静态树提升，这意味着 Vue 3 的编译器将能够检测到什么是静态组件，然后将其提升，从而降低了渲染成本。它将能够跳过未整个树结构打补丁的过程。

在这里插入图片描述

基于 Proxy 的观察者机制
目前，Vue 的反应系统是使用 ObectDefineProperty 的 getter 和 setter。 但是，Vue 3 将使用 ES2015 Proxy 作为其观察者机制。 这消除了以前存在的警告，使速度加倍，并节省了一半的内存开销。

为了继续支持 IE11，Vue 3 将发布一个支持旧观察者机制和新 Proxy 版本的构建。

使 Vue 更小
Vue已经非常小了，在运行时（runtime）压缩后大约 20kb 。 但我们可以期待它会变得更加小，新的核心运行时压缩后大概 10kb 。 这将在很大程度上通过消除不使用的库(也称为Tree Shaking)来实现。 例如，如果您没有使用 过渡（transition）元素，则不会包含它。

下面您可以看到 hello world 应用程序与压缩后的大小的比较。

使其更具可维护性
虽然大多数 Vue 开发人员都没有在库本身上工作，但很高兴知道 Vue 3 将带来更多可维护的源代码。 它不仅会使用 TypeScript ，而且许多软件包将被解耦，使所有内容更加模块化。

在这里插入图片描述

更多的原生支持
运行时内核也将与平台无关，使得 Vue 可以更容易地与任何平台（例如Web，iOS或Android）一起使用。

更易于开发使用
Observer 模块已被解压缩到自己的包中，允许您以新的方式使用它：

在这里插入图片描述

跟踪重新渲染的位置也会更容易。 在 Evan 的演讲中，他做了一些实时编码，并展示了如何跟踪 Vue 应用程序（使用下面的代码）来找出触发组件重新渲染的内容。 这在更大的应用程序和性能微调中非常有用。

在这里插入图片描述

Vue 3.0 还会改进对 TypeScript 的支持，允许在编辑器中进行高级的类型检查和有用的错误和警告。

在这里插入图片描述

实验性的 Hooks API
当我们需要在 Vue 中共享两个组件之间的行为时，我们通常使用 Mixins 。然而，Evan 正在尝试使用 Hooks API 来避免来自 Mixins 的一些问题，并且更适合使用惯用的 Vue 代码。

实验性的 Time Slicing 支持
当您有许多组件同时尝试重新渲染时，任何浏览器都可以开始变得很慢，从而使用户体验下降。

Evan展示了他如何尝试使用 Time Slicing，将 JS 的执行分解为几个部分，如果有用户交互需要处理，这些部分将提供给浏览器。

在这里插入图片描述

小结
我已经喜欢用Vue进行编码了，我很高兴能看到 Vue 更具竞争力，模块化，更容易调试和更多的开发乐趣。 另外上面说的这些内容除了“明年晚些时候”之外，还没有一个明确的发布日期。