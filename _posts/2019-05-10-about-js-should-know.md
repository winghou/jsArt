---
layout: post
title: 关于javascript你需要知道的
date: Fri May 10 2019 17:25:49 GMT+0800 (中国标准时间)
---
>写在前面：平时开发中总是遇见相同的问题，但很多时候都需要重新查找相关资料才可以，不但浪费了时间，而且每次都有种重新开始的感觉。。。因此将这些常见问题总结在一起，后续再有相关问题，都将其归为一类进行总结对比学习。

#### 参考资料

#### javascript的前世今生

#### 基本概念

##### 严格模式

ECMAScript 5引入严格模式的概念，是为javascript定义了一种不同的解析与执行模型。在严格模式下，ECMAScript 3中不确定的行为或某些不安全的操作都做了一些限制或错误处理。要在整个脚本启用严格模式，可以在顶部添加：`use strict`

这段代码看似为字符串，而且也没有赋值给任何变量，但其实是一个**编译指示（pragma），用来告诉支持的js引擎切换到严格模式**。这是为了不破坏ECMAScript 3语法而特意选定的语法，还可以在指定函数为严格模式：

```js
function doSomething(){
  'use strict'
  // TODO
}
```

##### 自动分号

语句的分号不是必须的，但建议任何时候都加上。因为：

- 避免不必要的错误(不完整输入)
- 代码结尾处没有分号会导致压缩错误
- 加上分号某些情况下会增进代码性能(解析器不必再花时间推测哪里插入分号)

##### 代码块 {}

可以借鉴c风格的语法把多条语句组合在一个代码块里，虽然if语句只在执行多条语句时，才要求使用代码块，但最佳实践是始终使用代码块，即使只有一条语句，如：

```js
if (test) console.log('test') // 有效但容易出错，不要使用

if (test) {
  console.log('test') // 推荐
}
```

##### 变量

ECMAScript的变量是松散型的，也就是可以保存任何类型的数据。换句话说，**每个变量仅仅是一个用于保存值得占位符**而已，定义变量时，要使用`var,let,const`等操作符(同时也是关键字)，后跟变量名（即标识符）

```js
var msg
```

上面代码定义了一个名为`msg`的变量，可以用来保存任何值(上面那样未经初始化的变量，会保存一个特殊的值`undefined`)。

```js
var msg = 'hi javascript'
msg = 100 // 有效但不推荐
```

像上面那样先初始化一个字符串数据类型，后又改为数字类型，这种即改变变量值又改变值类型的行为不推荐。

#### 数据类型

鉴于ECMAScript是松散类型的，因此需要一种手段来检测变量的数据类型，`typeof`就是负责提供这方面信息的操作符。

```js
typeof 'hello'      // 'string'
typeof true         // 'boolean'
typeof 100          // 'number'
typeof undefined    // 'undefined'
typeof (null)       // 'object'
typeof function(){} // 'function'
```

##### Null 与 Undefined

**注意：**`typeof`是一个操作符而不是函数，因此例子中的圆括号可以使用，但不是必需的。这里`typeof null`返回`'object'`，因为`null`被认为是一个**空的对象引用**，其实更底层原因是因为不同的对象在计算机底层都表示为二进制，在`JavaScript`中二进制前三位都为 0 的话会被判断为 `object` 类型，`null`的二进制表示是全 0，自然前三位也是 0，所以执行`typeof` 时会返回`'object'`。

`null`表示"没有对象"，即该处不应该有值。`undefined`表示"缺少值"，就是此处应该有一个值，但是还没有定义。

注意：对未经声明或未初始化的变量，使用`typeof`都会返回`'undefined'`，但无法使用`delete`删除一个直接通过`var`声明的全局变量

```js
var aa
typeof aa // 'undefined'
typeof bb // 'undefined'
delete aa // false
delete bb // true

// 另外注意
null == undefined   // true , 实际上undefined值是派生自null值的(null出现的早)
+ null === 0        // true ,+ 其实就是数字转化，相当于Number(null)
Number(null) === 0  // true
- null === -0       // true , - 也是数字转化，但有符号问题
+ 0 === - 0         // true
```

如果定义的变量准备在**将来用于保存对象，那么最好将该变量初始化为`null`而不是其他值**。这样只要直接检测是否为`null`就可以知道变量是否已经保存一个对象的引用了。

参考：[null和undefined的由来及区别][nullAndundefined(阮一峰)]

##### Number

Number类型在ECMAScript中，使用[IEEE754][IEEE_754URL]格式来表示整数和浮点数(又称双精度数值)。常见的格式有10，2，8，16进制等。

8进制的第一位必须是0，然后是8进制数字(0~7)，如果字面值中的数字超过了（0~7），那么前导0被忽略，后面的数值将当做10进制解析，如下

```js
var octalNum1 = 070 // 8进制56 即 (7 * 8 + 0 * 8)
var octalNum2 = 079 // 无效的8进制，丢弃前导0，后面解析为10进制，即79
var octalNum3 = 08  // 无效的8进制，丢弃前导0，后面解析为10进制，即8
```

**注意：**在严格模式下，8进制前导0变为`0o`，即

```js
var num1 = 0o71 // 8进制57 即 (7 * 8^1 + 1 * 8^0)
```

十六进制字面量的前两位必须是`0x`，后面跟十六进制数字（0~9及A-F），字母大小写均可。在进行算术计算时，所有八进制和十六进制表示的数值最终都将被转换为十进制数值。

```js
var hexNum1 = 0xA  // 十六进制10
var hexNum2 = 0XA  // 十六进制10
var hexNum3 = 0x1f // 十六进制31 即 1 * 16^1 + 15 * 16^0
```

###### 浮点数

所谓浮点数，就是该数值必须包含一个小数点，且小数点后面至少有一个数字，**虽然小数点前可以没有数字但不推荐**。由于浮点数需要的内存空间是整数值的两倍，因此ECMAScript会不失时机的将浮点数转换为整数值。显然，如果小数点后面没有任何数字(如：1.)，或本身就是一个整数(如：10.0)，则都会转换成整数。

对于那些极大或极小的数值，可以用e表示法（科学计数法）表示的浮点数表示。e表示法表示的数值等于e前面的数值乘以10的指数次幂

```js
var floatNum1 = 3.125e7;    // 等于31250000，即3.125 * 10^7
var floatNum2 = 0.0000003;  // 等于3e-7
```

浮点数的最高精度是17位小数，但在进行算术运算时其精确度远远不如整数，如：

```js
0.1 + 0.2 === 0.30000000000000004 // 小数点后正好17位
0.15 + 0.15 === 0.3 // true
```

**注意：**关于浮点数值计算会产生舍入误差的问题，这是因为使用基于[IEEE754][IEEE_754URL]数值的浮点计算的通病，ECMAScript并非独此一家，其他使用相同数值格式的语言也存在这个问题。当然如果只是想表面的'修复'此问题，可以如下：

```js
// 注意结果有的为字符串格式
(0.1 + 0.2).toFixed(10)             // '0.3000000000'
parseFloat((0.1 + 0.2).toFixed(10)) // 0.3
(0.1+0.2).toPrecision(1)            // '0.3'
parseFloat((0.1+0.2).toPrecision(1))// 0.3
```



#### 函数

ECMAScript函数可以封装任意多条语句，且不介意传进来多少参数，什么数据类型，即便定义的参数与实际调用时传递的数量不一致也没有关系，因为ECMAScript中的参数在内部是用一个**伪数组**来表示，这便是`arguments`对象,具有length属性但并不是数组的实例(也不具有数组常用api)。

ECMAScript函数中命名的参数只是提供便利，但不是必需。另外，在命名参数方面，其他语言可能需要事先创建一个函数签名，而将来的调用必需与该签名一致，但ECMAScript函数并没有此要求，因此ECMAScript函数也不能重载(其实可以理解为同名函数，根据参数名的不同分别执行多次，但在js中同名函数会有覆盖且参数是伪数组，因此无法重载，但可以根据参数个数不同实现不同的逻辑，进而模拟重载)。

```js
function doAdd(num1, num2){
  arguments[1] = 20;
  console.log(arguments[0] + num2);
}

doAdd(10, 10) // 30
```

修改`arguments[1]`会自动映射到num2上，因为`arguments`对象中的值会自动映射到对应的命名参数。但注意：**并不是说这两个值访问相同的内存空间，他们的内存空间是独立的，但值会同步**。

有地方说，上述影响是单向的，即修改`arguments`会自动映射到对应的命名参数，反之不行？但下面代码在chrome可行，也就是说这种改变是双向的。。。

```js
function test(num1, num2){
  arguments[1] = 20;
  console.log(num2);
  num2 = 40;
  console.log(arguments[1])
}

test() // 20 40
```

但在严格模式下，会有些不同，即`arguments`对象**变化时不再与对应的命名参数自动同步值**，如下：

```js
function test(num1, num2){
  'use strict'
  arguments[1] = 20;
  console.log(num2);
  num2 = 40;
  console.log(arguments[1])
}

test() // 2 20
```

[nullAndundefined(阮一峰)]: http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html '阮一峰'
[IEEE_754URL]: https://zh.wikipedia.org/wiki/IEEE_754 '维基百科'