---
layout: post
title: 那些我们熟悉的skills
date: Wed Jan 30 2019 11:55:28 GMT+0800 (中国标准时间)
---


### 常见的一些问题及相关参考链接

如果动画正在执行时，数据发生更新应该如何处理？为看起来流畅，应该先等动画执行完，再更新数据，再开始动画，但又如何知道什么时候结束动画？如果不这样有没有其他方式？


以后不能说不知道，先思考一下如何才能得到？不会先留着

1. 支付逻辑，
2. 埋点逻辑
3. docker
4. 小程序
5. 部署脚本
6. 框架
7. cas单点登录
8. vue源码
9. ts
10. jenkins
11. 数据结构及算法
13. 微信sdk,授权，支付，分享
14. 唤起app
15. 线程，进程，微任务，宏任务
16. Socket协议
17. http5,css3,canvas,常见攻击，websocket，pwa,


#### 
linux mac

#### ***显示设备相关***
***css像素***<br/>
参考：[css、物理、设备、独立设备像素][cssPxDevicePxUrl]

浏览器里的一切长度都是css像素为单位，css像素的单位是px(pixel像素的缩写)，他是图像显示的基本单元，**既不是一个确定的物理量，也不是一个点或者小方块，而是一个抽象概念**。。。

***注意：***物理像素其实就等价于设备像素<br/>

在css规范中，单位有相对和绝对之分，而px就是一个相对单位，相对的是**设备像素(device pixel)**

在同一个设备或不同的设备上，**每一个css像素所代表的物理像素是可以变化的**。。。

不同的设备，图像基本采集单元是不同的，显示器上的物理像素等于显示器的点距，而打印机的物理像素等于打印机的墨点，而衡量二者的单位分别为ppi和dpi。<br/>
**ppi：**每英寸(2.54cm)多少像素数，放到显示器上说的是每英寸多少物理像素及显示器设备的点距。<br/>
**dpi：**每英寸(2.54cm)多少点<br/>

由于不同设备的物理像素的大小是不一样的，所以css规范认为，浏览器应该对css像素进行调节，使得浏览器中1css像素的大小在不同设备上看上去大小总是差不多的。。。为了达到这一点，浏览器可以直接根据设备的物理像素大小进行换算。

由于css像素是视角像素，所以在真正实现时，为了方便都是根据设备像素换算的，浏览器根据硬件设备能够直接获取css像素(也就是dpr)。

假设我们用pc浏览器打开一个页面，浏览器此时的宽度为800px，页面上有一个400px宽的块级容器，则此时块级容器占屏幕一半，若放大(cmd加上+)200%，也就是原来的两倍，此时块状容器则横向占满整个浏览器<br/>
另外body的样式属性zoom效果和(cmd加+)效果一样，只是如果用zoom修改了屏幕大小，需要再用尺寸/zoom才是真实的大小。。。
```js
// getComputedStyle返回计算后的属性对象集合
document.body.style.zoom = 0.8
var zoomVal = window.getComputedStyle(document.body).zoom;
newHeight = window.innerHeight / zoomVal
```

此时我们没有调整浏览器窗口大小，也没有改变块状容器的css宽度，但是却看上去变大了一倍。。。这是因为**我们把css像素放大了两倍**(css像素代表的物理像素数是可以变化的)

正常情况下，css像素与屏幕像素是1：1的关系，但浏览器的放大操作让这个比例发生了变化，也就是现在1css像素 = 2个设备像素，而设备像素的密度是不会变化的，出厂便确定(单位pt，绝对单位)，因此放大2倍的容器就占满了整个屏幕。

**dpr：**DPR = 设备像素 / css像素<br/>
其实，还有dip，也就是设备独立像素(顾名思义是独立于设备之外的像素)，也叫逻辑像素，其实也就是css像素。。。<br/>
所以：CSS像素 = 设备独立像素 = 逻辑像素

在移动端浏览器及某些桌面浏览器中，window对象有`devicePixelRatio`属性，也就是`devicePixelRatio = 物理像素 / 独立像素`。在mac上打印这个值为4，而普通的浏览器是1，这就是所谓的Retina屏。

看下图：
![dpr&ppi](/jsArt/assets/images/js-theory/dpr-ppi.png)
如果对于一个页面，我们分别放在不同devicePixelRatio的设备上，就会出现上图的效果。也就是说，高devicePixelRatio的设备上ppi更大，每个物理像素点更小更密集，因此此时显示就小又清晰。。。

然而在现实中，这两者效果却是一样的。这是因为Retina屏幕把2x2个像素当1个像素使用。比如原本44像素高的顶部导航栏，在Retina屏上用了88个像素的高度来显示。导致界面元素都变成2倍大小，反而看起来效果一样了，但画质更清晰。。。


#### ***HTML相关***
***viewport***<br/>
首先，移动设备上的浏览器认为自己必须让所有的网站都能正常显示，即使是那些不是为移动设备设计的网站。。。那如何设置这个宽度呢？太窄了布局会错乱，太宽了会出现滚动条，什么又是不窄不宽呢？

因此有三种viewport来解决这些问题：
1. layout viewport (document.documentElement.clientWidth)
2. visual viewport (window.innerWidth)
3. ideal viewport (设备不同，值不同)

layout是为了防止太窄，布局出现错乱规定的一个较宽的值。layout viewport 的宽度是大于浏览器可视区域的宽度的，所以我们还需要一个viewport来代表浏览器可视区域的大小，这个viewport叫做 visual viewport；但越来越多的网站为移动设备单独设计，因此需要一个完美适配移动设备的viewport，也就是不能缩放，不能出现滚动条，不能显示异常等。。。这个viewport就是ideal viewport，也就是理想viewport。

ideal viewport并不是一个固定的尺寸，不同的设备拥有不同的ideal viewport。所有的iphone的ideal viewport宽度都是320px，无论它的屏幕宽度是320还是640，也就是说，在iphone中，css中的320px就代表iphone屏幕的宽度。

是安卓设备就比较复杂了，有320px的，有360px的，有384px的等等，具体可参考：[各设备的理想viewport][androidViewportWidthSizeUrl]


***利用meta控制viewport***<br/>
移动设备默认的viewport是layout viewport，也就是那个比屏幕要宽的viewport，但在进行移动设备网站的开发时，我们需要的是ideal viewport。那么怎么才能得到ideal viewport呢？这就该轮到meta标签出场了。

meta viewport 标签首先是由苹果公司在其safari浏览器中引入的，目的就是解决移动设备的viewport问题。后来安卓以及各大浏览器厂商也都纷纷效仿，引入对meta viewport的支持，
```html
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
```
该meta标签的作用是让当前viewport的宽度等于设备的宽度（此时viewport的宽度就是ideal viewport宽度了），同时不允许用户手动缩放。也许允不允许用户缩放不同的网站有不同的要求，但让viewport的宽度等于设备的宽度，这个应该是大家都想要的效果，如果你不这样的设定的话，那就会使用那个比屏幕宽的默认viewport，也就是说会出现横向滚动条。

**注意：**在iphone和ipad上，无论是竖屏还是横屏，宽度都是竖屏时ideal viewport的宽度。

```html
<meta name="viewport" content="width=device-width">
<meta name="viewport" content="initial-scale=1">
```
其实上面两种写法效果一样，都可以把当前的viewport变为ideal viewport。这是因为`initial-scale=1`只是不对当前页面缩放。。。但我们需要知道这个缩放是相对于谁的？答案就是`ideal viewport`，因此相对于ideal viewport缩放是1，不正好就是ideal viewport的宽度了。。。

那如果出现下面二者同时存在情况呢？
```html
<meta name="viewport" content="width=400, initial-scale=1">
```
答案是取二者中最大值。。。比如这里ideal viewport是480px，则取480px;

**总结：**最后，总结一下，要把当前的viewport宽度设为ideal viewport的宽度，既可以设置 width=device-width，也可以设置 initial-scale=1，但这两者各有一个小缺陷，就是iphone、ipad以及IE会横竖屏不分，通通以竖屏的ideal viewport宽度为准。所以，最完美的写法应该是，两者都写上去，这样就 initial-scale=1 解决了 iphone、ipad的毛病，width=device-width则解决了IE的毛病(IE不认initial-scale属性)：
```html
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
```

***关于缩放及initial-scale的默认值***<br/>
前面我们知道缩放是相对于 `ideal viewport`的，缩放值越大，当前的viewport的宽度就越小。比如在iphone中，ideal viewport的宽度是320px，如果设置`initial-scale=2`,此时viewport的宽度变为只有160px。。。感觉160比320小了，但是我们要知道，px是个动态单位，因此放大2倍后，1px相当于之前的2倍。。。

所以：visual viewport宽度 = ideal viewport宽度 / 当前缩放值

多数浏览器都符合这个理论，但是安卓上的原生浏览器以及IE有些问题。安卓自带的webkit浏览器只有在 initial-scale = 1 以及没有设置width属性时才是表现正常的，也就相当于这理论在它身上基本没用；而IE则根本不甩initial-scale这个属性，无论你给他设置什么，initial-scale表现出来的效果永远是1。

好了，现在再来说下 initial-scale 的默认值问题，就是不写这个属性的时候，它的默认值会是多少呢？很显然不会是1，因为当 initial-scale = 1 时，当前的 layout viewport 宽度会被设为 ideal viewport 的宽度，但前面说了，各浏览器默认的 layout viewport 宽度一般都是980啊，1024啊，800啊等等这些个值，没有一开始就是 ideal viewport 的宽度的，所以 initial-scale 的默认值肯定不是1。

**结论：**在iphone和ipad上，无论你给viewport设的宽的是多少，如果没有指定默认的缩放值，则iphone和ipad会自动计算这个缩放值，以达到当前页面不会出现横向滚动条(或者说viewport的宽度就是屏幕的宽度)的目的。


再来看看淘宝针对不同设备做的scale处理(其实主要针对的是iphone，adroid的一直为1):
```js
var dpr = 0;
var scale = 0;
var match = document.querySelector('meta[name="viewport"]').getAttribute('content').match(/initial\-scale=([\d\.]+)/)
if (match) {
    scale = parseFloat(match[1]);
    dpr = parseInt(1 / scale);
}
if (!dpr && !scale) {
    var isAndroid = win.navigator.appVersion.match(/android/gi);
    var isIPhone = win.navigator.appVersion.match(/iphone/gi);
    var devicePixelRatio = win.devicePixelRatio;
    if (isIPhone) {
        // iOS下，对于2和3的屏，用2倍的方案，其余的用1倍方案
        if (devicePixelRatio >= 3 && (!dpr || dpr >= 3)) {                
            dpr = 3;
        } else if (devicePixelRatio >= 2 && (!dpr || dpr >= 2)){
            dpr = 2;
        } else {
            dpr = 1;
        }
    } else {
        // 其他设备下，仍旧使用1倍的方案
        dpr = 1;
    }
    scale = 1 / dpr;
}
var doc = win.document;
var docEl = doc.documentElement;
docEl.setAttribute('data-dpr', dpr);
if (!metaEl) {
    metaEl = doc.createElement('meta');
    metaEl.setAttribute('name', 'viewport');
    metaEl.setAttribute('content', 'initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no');
    if (docEl.firstElementChild) {
        docEl.firstElementChild.appendChild(metaEl);
    } else {
        var wrap = doc.createElement('div');
        wrap.appendChild(metaEl);
        doc.write(wrap.innerHTML);
    }
}
```
在高分屏下，dpr越大，scale越小。。。由公式：visual viewport宽度 = ideal viewport宽度 / 当前缩放值，可以得到visual viewport越大，这样便和设计稿尺寸吻合了，同一个图片在不同手机上看着就大小一样了。。。？？？<br/>

参考：[淘宝具体实现flexible过程][taoBaoFlexibleUrl]

#### ***CSS相关***
***margin collapsing***<br/>
**块级元素**的**上外边距和下外边距**有时会合并(或折叠)为一个外边距，其**大小取其中大者**，可理解为外边距折叠或外边距合并，**浮动元素和绝对定位元素的外边距不会折叠**

几种折叠场景：
1. 相邻元素之间（除非后面的元素清除之前的浮动）
2. 父元素与其第一个或最后一个子元素之间
3. 空的块级元素

其实说到底，只要margin-top和margin-bottom之间没有**一些东西**隔开，就会发生合并。。。而这里的**一些东西**可以是：边框、内边距、行内内容、height、min-height 等。<br/>
参考：[margin合并(mdn)][marginCollapsingUrl]


***BFC(Block Formatting Context)***<br/>

块格式化上下文是布局过程中生成块级盒子的区域，只有块级盒子才可以参与，也是浮动元素与其他元素的交互限定区域。<br/>

常见的文档流：标准流、定位流、浮动流。。。而标准流就是BFC中的FC，另外还有IFC(行级格式化上下文)、GFC(网格布局格式化上下文)、FFC(自适应格式化上下文)。

可以通俗的理解：BFC为某个**元素的一个css属性**，只不过这个属性**不能被开发者显式的修改**，拥有这个属性的元素对内部元素和外部元素会表现出一些特性，这就是BFC

触发生成BFC的条件：
1. 根元素，即HTML元素
2. float的值不为none
3. overflow的值不为none
4. display的值为inline-block、table-cell、table-caption
5. position的值为absolute或fixed

BFC表现出的特性：
1、同一个BFC下，边距合并
```html
 <!-- 1，在同一个BFC下，外边距会发生重叠
    如下，第一个div的margin-bottom会与第二个div的margin-top合并
    取二者大值，都是50px，所以合并后为50px
     -->
<body>
  <div style="width: 50px; height: 50px; margin: 50px;"></div>
  <div style="width: 50px; height: 50px; margin: 50px;"></div>
</body>
<!-- 1.1，如果不想合并，只需将其中给一个或都改为BFC即可，如下 -->
<!-- 如果直接给第二个div添加overflow无效。可添加display: inline-block; -->
<body>
  <div style="width: 50px; height: 50px; margin: 50px;"></div>
  <div style="overflow: hidden;">
    <div style="width: 50px; height: 50px; margin: 50px;"></div>
  </div>
</body>
```

2、同一个BFC下，浮动元素不占空间
```html
<!-- 内部的div虽然有高度，但无法撑开外层div -->
<div style="border: 1px solid #ccc">
  <div style="width: 50px;height: 50px;float: left;"></div>
</div>

<!-- 利用BFC思想，给父元素添加触发生成BFC条件的任意一条，都可以撑开 -->
<div style="border: 1px solid #ccc; overflow: hidden">
  <div style="width: 50px;height: 50px;float: left;"></div>
</div>
```

3、文字环绕和三栏自适应布局
```html
<!-- float的设计之初就是文字环绕用 -->
<div>
  <div style="width: 50px;height: 50px;float: left;"></div>
  <div>这是一段文字，应该围绕左侧盒子布局；</div>
</div>

<!-- 利用BFC思想，添加overflow: hidden，可以不遮挡也不环绕 -->
<!-- 注意对文字来说有点特殊，要针对性应用属性 -->
<div>
  <div style="width: 50px;height: 50px;float: left;"></div>
  <div style="overflow: hidden;">这虽然是一段文字，但现在应该不再围绕左侧盒子布局；</div>
</div>

<!-- 利用BFC思想，实现三栏布局 -->
<div>
  <div style="width: 50px;height: 50px;float: left;"></div>
  <div style="width: 50px;height: 50px;float: right;"></div>
  <div style="overflow: hidden;">这是一段文字，应该始终位于中间位置</div>
</div>
```

***一些css技巧***<br/>
参考：[css常用选择器(w3c)][w3choolCssSelectorUrl]


```css
/* 同时选中在（父元素的）子元素列表中，最后一个给定类型的元素p和a元素 */
p,
a:last-of-type
{
    margin-bottom: 0;
}
```

#### ***HTML5及CSS3相关***
参考：[HTML5(mdn)][html5MdnUrl]、[h5和css3新特性一览][html5&css3NewFeatureUrl]、[前端工程师手册][frontEndDatabaseUrl]<br/>

**HTML5**:<br/>
1. 一个新版本的html语言，具有新的元素，属性和行为
2. 有更大的技术集，允许更多多样化和强大的网站和应用程序。

主要改变有一下几个方面：
1. 语义
2. 通信
3. 离线 & 存储
4. 多媒体
5. 2d/3d 图形和效果
6. 性能和集成
7. 设备访问
8. 样式设计

**语义**:<br/>
1. 语义之新区块和段落元素`<section>, <article>, <nav>, <header>, <footer>, <aside> 和 <hgroup>.`能让你更恰当地描述你的内容是什么
2. `<audio> 和 <video> `元素嵌入和允许操作新的多媒体内容。
3. 表单改进，强制校验API，一些新的属性，一些新的`<input>` 元素type属性值(`placeholder,required,pattern,min,max,step,autofocus,multiple`) ，新的`<output>`元素。
4. 新的语义元素，除了上面的，还有例如` <mark>， <figure>， <figcaption>， <data>， <time>， <output>， <progress>， 或者 <meter>和<main>`，这增加了有效的 HTML5 元素的数量。

**通信**:<br/>
1. `webSocket`是h5开始提供的一种在单个tcp连接上进行全双工通讯的协议；
2. `WebRTC`即时通信，允许连接到其他人，直接在浏览器中控制视频会议，而不需要一个插件或是外部的应用程序。
3. `Server-sent events(SSE)`允许服务器向客户端推送事件，而不是仅在响应客户端请求时服务器才能发送数据的传统范式。

**离线 & 存储**:<br/>
参考：[indexedDB(阮一峰)][indexedDB(ruanyifeng)]<br/>
1. 离线资源(应用程序缓存)，火狐全面支持离线资源规范，其他浏览器部分支持、
2. Firefox 3 支持 WHATWG 在线和离线事件，这可以让应用程序和扩展检测是否存在可用的网络连接，以及在连接建立和断开时能感知到。
3. Web Storage存储(sessionStorage,localStorage)让web应用程序在客户端存储结构化数据
4. indexedDB在浏览器中存储大量结构化数据，并且能够在这些数据上使用索引进行高性能检索

***注意：***<br/>
1. window.sessionStorage是会话期间(也就是同一个标签，刷新后也有效)
2. LocalStorage 在 2.5MB 到 10MB 之间（各家浏览器不同），而且不提供搜索功能，不能建立自定义的索引。
3. Cookie的大小不超过4kb，且每次请求都会发送回服务器
4. IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL，MongoDB等非关系型数据库。
5. 关系型是指采用关系模型(二维表格模型)组织数据的数据库，具有事务一致性(任何人看到的数据都一致)，也因此读写性能稍差
6. 非关系型大多开源，大多以键值对存储，且结构不固定，每一个元组可以有不一样的字段，每个元组可以根据需要增加一些自己的键值对，这样就不会局限于固定的结构，可以减少一些时间和空间的开销。

**多媒体**:<br/>
1. `<audio> 和 <video> `元素嵌入并支持新的多媒体内容的操作。
2. 使用 Camera API，允许使用，操作计算机摄像头，并从中存储图像。

**2d/3d 图形和效果**:<br/>
1. canvas
2. WebGL 通过引入了一套非常地符合 OpenGL ES 2.0 并且可以用在 `HTML5<canvas>`元素中的 API 给 Web 带来了 3D 图像功能。
3. 一个基于 XML(Extensible Markup Language,可扩展标记语言，设计之初用来传输和存储数据，而html用来显示数据) 的可以直接嵌入到 HTML 中的矢量图像格式。

**性能和集成**:<br/>
1. web workers可以把js运算委托给后台线程，通过允许这些活动以防止使交互型事件变得缓慢
2. 即时编译的js引擎功能更加强大，性能更杰出
3. History API允许对浏览器历史记录进行操作
4. contentEditable 属性：把你的网站改变成 wiki !
5. 拖放，HTML5 的拖放 API 能够支持在网站内部和网站之间拖放项目。
6. requestAnimationFrame下次重绘之前调用指定的回调函数更新动画以获得更优性能
7. 全屏API，选择全屏展示的元素(如：video，html等)，调用Ele.requestFullscreen() 
8. 在线和离线事件,navigator.onLine为true表示在线，否则离线

**设备访问**:<br/>
1. 使用 Camera API，允许使用，操作计算机摄像头，并从中存储图像。
2. 对于用户按下触控屏的事件作出反应的处理程序
3. 地理位置定位navigator.geolocationt对象提供，返回低精度位置
```js
// getCurrentPosition是异步操作，回调函数对返回的数据进行处理
navigator.geolocation.getCurrentPosition(function(position) {
  do_something(position.coords.latitude, position.coords.longitude);
});
```
4. 检测设备方向。
```js
// DeviceOrientationEvent是加速度传感器检测到设备在方向上发生变化时触发
window.addEventListener("deviceorientation", handleOrientation, true);
// DeviceMotionEvent是监听的加速度变化而不是方向
window.addEventListener("devicemotion", handleMotion, true);
```

**样式设计**:<br/>
1. `box-shadow`设置边框阴影，还可以设置多背景
2. `border-image`边框图片，`border-radius`设置圆角
3. css Transitions/Transform/@keyframes
4. @font-face规则自定义字体
5. 多栏布局及css灵活方框布局

#### ***Javascript相关***
***常用算法***
```js
// 1、冒泡排序
function bubleSort(arr) {
  if(!arr) return
  let arrLen = arr.length
  for(let i = 1; i < arrLen; i++){
    for(let j = 0; j < arrLen - i; j++){
      if(arr[j] > arr[j+1]){
        // 数组解构
        [arr[j+1],arr[j]] = [arr[j],arr[j+1]]
      }
      // 还可以这样,
      // arr[j] > arr[j+1] && ([arr[j+1], arr[j]] = [arr[j], arr[j+1]])
    }
  }
  return arr
}

// 2、数组去重
// 2.1，利用forEach，将数组的元素取出来作为对象的key，然后赋予任意值，最后获取key列表
var uniqueArr = arr => {
  let obj = {}
  arr.forEach((val) => {
    obj[val] = 0
  })
  // 注意，返回的是可枚举的字符串数组
  return Object.keys(obj)
}

// 2.2，filter，indexOf只会返回第一个匹配数据的index
var uniqueArr = arr => {
  // Array.prototype.filter(callback(element[, index[, array]])[, thisArg])
  // 注意可选参数的意义；thisArg为执行callback时this值
  return arr.filter((ele, index, array) => {
    return index === array.indexOf(ele)
  })
}

// 2.3，set
var uniqueArr = arr => {
  // 注意只适用于数组为基本数据类型的
  return [...new Set(arr)]
}

// 2.4，reduce
// Array.prototype.reduce(callback(accumulator,currentValue[, currentIndex[, array]])[, initialValue])
// accumulator是累计器最终的值，若initialValue没传则默认取数组第一项，currentValue则自动为第二项
// 下面给累加器传的值是一个对象，相当于2.1方法的另外一种方式
var uniqueArr = arr.reduce((map,item) => {
  map[itme] = 0
  return map
}, {})
Object.keys(uniqueArr)

// 3、字符串反转
var reverseString = str => {
  return [...str].reverse().join('')
}

// 4、统计一个字符串中出现频率最高的字母或数字
var strChar = str => {
  let string = [...str],
      maxVal = '',
      obj = {},
      max = 0;
  string.forEach( val => {
    obj[val] = obj[val] === undefined ? 1 : obj[val] + 1
    if(obj[val] > max){
      max = obj[val]
      maxVal = val
    }
  })
  return maxVal
}
```

***常用函数***
```js
// 防抖
// 小于设置的interval时间间隔都不会触发，因为clearTimeout了
function debounce(fn, interval = 300) {
  let timeout = null
  return function () {
    clearTimeout(timeout)
    timeout = setTimeout(() => {
      fn.apply(this,arguments)
    },interval)
  }
}
window.onresize = debounce(()=>{console.log('resizing')},500)
window.addEventListener('resize',debounce(()=>{console.log('resizing')},500))

// 节流
function throttle(fn, interval) {
  // let canRun = null // 注意这里canRun不是null
  let canRun = true
  return function () {
    // !canRun && return // 这样写错误
    if(!canRun) return
    canRun = false
    setTimeout(()=>{
      fn.apply(this, arguments)
      canRun = true
    },interval)
  }
}
window.onresize = throttle(()=>{console.log('resizing')})
//这里的e就是resize事件，但这里打印的是[object Event],因为``里面是字符串
window.onresize = throttle((e)=>{console.log('resizing',`e is ${e}`)}) 
```

***常用正则***<br/>
参考：[通俗的正则][commonRegexUrl]、[正则表达式全集][allRegexUnitUrl]、[mdn正则表达式][mdnRegexUrl]

正则其实是有规律可循的，主要由以下几部分组成：
1. 元字符(构成正则的基本元素)
1.1、 . 匹配除换行符以外的任意字符<br/>
1.2、 \w 匹配包括下划线的任何单词字符，等价于[A-Za-z0-9_]<br/>
1.3、 \W 匹配任何非单词字符，等价于[^A-Za-z0-9_]<br/>
1.4、 \s 匹配任意的空白符（空格，制表符，换页符）<br/>
1.5、 \b 匹配单词的开始或结束(/\ba/.test('ab') ; /a\b/.test('da'))<br/>
1.6、 ^ 匹配字符串的开始<br/>
1.7、 $ 匹配字符串的结束<br/>
```js
// 利用基本元素可以写简单的正则表达式
\abc或者^abc // 匹配有abc开头的字符串
^\d\d\d\d\d\d\d\d$ // 匹配8位数字的QQ号码
^1\d\d\d\d\d\d\d\d\d\d$ // 匹配1开头11位数字的手机号码
```

2. 重复限定符
2.1、 * 重复0次或更多次<br/>
2.2、 + 重复一次或更多次<br/>
2.3、 ？重复0次或一次<br/>
2.4、 {n}重复n次<br/>
2.5、 {n,}重复n次或更多次<br/>
2.6、 {n,m}重复n到m次<br/>

```js
// 改造上面的正则表达式
\d{8}$ // 匹配8位数字的QQ号码
^1\d{10}$ // 匹配1开头11位数字的手机号码
^\d{14,18}$ // 匹配14~18位的数字
^ab*$ // 匹配a开头，0个或多个b结尾的字符串

// 注意查看下面的，或许因为数字太大，js引擎在匹配之前做了一层转化
/^1\d{10}/.test(176108358151234567892) // true
/^1\d{10}/.test(1761083581512345678923) // false
console.log(Number(1761083581512345678923)) // 1.7610835815123457e+21
/^1\d{10}/.test(1.7610835815123457e+21) // false
```

3. 分组
3.1、 (pattern)匹配pattern并获取这一匹配
```js
^(ab)* // 匹配0个或多个ab开头
```

4. 转义 <br/>
```js
^(\(ab\))*  // 匹配0个或多个(ab)开头
```

5. 条件或符号 <br/>
5.1 ^(130|131|132|155|156|185|186|145|176)\d{8}$<br/>

6. 区间 ^((13[0-2])|(15[56])|(18[5-6])|145|176)\d{8}$ <br/>
6.1 限定0-9范围可以为 [0-9]<br/>
6.2 限定a-z范围可以为 [a-z]<br/>
6.3 限定某些数字 [165]<br/>

正则表达式的几种方法
1. exec 在字符串中查找，返回数组(未匹配到返回null)
2. test 测试是否包含指定字符串，返回true或false
3. match 在字符串中查找，返回数组(未匹配到返回null)
4. search 在字符串中查找，返回匹配到的位置索引(失败返回-1)
5. replace 在字符串中查找，并且替换为指定的字符
6. split 在字符串中查找指定字符，并且以指定字符切割字符串，返回切割后的字符串数组(不含被切字符)


***基于对象与OOP(面向对象)***<br/>
js的核心是支持面向对象，但准确来说是基于对象
>oop（object oriented programming）面向对象编程是用抽象方式创建基于现实世界模型的一种编程方式。

基于对象，就是一个工程师建了一栋房子，然后其它的工程师按照这个房子的样子去建造其它的房子<br/>
面向对象，就是一个工程师再图纸上设计出一栋房子的样子，然后其它工程师按照这个图纸的设计去建造房子<br/>

也就是说:<br/>
基于对象是先有一个具体的对象，然后在这个对象的基础上创建新的对象<br/>
面向对象就是先有一个抽象的对象描述，然后以此为蓝本构建具体对象<br/>

一般的面向对象语言 中的类的概念 都是 一个 抽象的声明，当 new 出来一个对象的时候，就是依据 类的声明给造出来的，就像是模子里面刻出来的。<br/>
javascript是基于对象的，那么它所有的对象都是从原型对象继承而来，和原型模式大概相似，Javascript的动态特性，可以随时的给对象的原型添加方法或属性，然后new出来的对象就有了。

但作为es6的class，其实并不能说是面向对象，可以将class看成一个语法糖，新的class写法只是让对象原型的写法更加清晰，**更像面向对象编程的语法**而已，如下：
```js
// 构造函数
function Point (x) {
  this.x = x
}
// 给原型添加属性
Point.prototype.toString = function () {
  return `this.x is ${this.x}`
}

// class写法
class Point {
  // 构造函数
  constructor (x) {
    this.x = x
  }
  // 直接添加方法
  toString () {
    return `this.x is ${this.x}`
  }
}
// 实例化
var newPoint = new Point('test')
newPoint.toString() // this.x is test

// super关键字是用于访问和调用一个对象的父对象上的函数

super([arguments]) // 调用父类或父对象的构造函数，参数作为构造函数的参数传入
super.functionOnParent([arguments]) // 指定父类或父对象上的方法并调用

// class实现继承是通过 extends
class colorPoint extends Point {
  constructor (x, color) {
    super(x)
    this.color = color
  }
  toString () {
    return `this.color is ${this.color} & ${super.toString()}`
  }
}
```

***常用设计模式***<br/>
参考:[js十大常用设计模式][tenDesignStylesUrl]、<br/>
工厂模式：解决实例化多个类似对象产生重复的问题，如下

```js
function CreatePerson(name,age,sex) {
  var obj = {};
  obj.name = name;
  obj.age = age;
  obj.sex = sex;
  obj.sayName = function(){
    return this.name;
  }
  return obj;
}
var p1 = new CreatePerson("longen",'28','男');
var p2 = new CreatePerson("tugenhua",'27','女');
```

单体模式：将代码组织为一个逻辑单元的手段，这个逻辑单元中的代码可以通过单一变量进行访问。
1. 可以用来划分命名空间，减少全局变量的数量。
2. 使用单体模式可以使代码组织的更为一致，使代码容易阅读和维护。
3. 可以被实例化，且实例化一次。

```js
// 单体模式
var Singleton = function(name){
  this.name = name;
};
Singleton.prototype.getName = function(){
  return this.name;
}
// 获取实例对象
var getInstance = (function() {
  var instance = null;
  return function(name) {
    if(!instance) {
      instance = new Singleton(name);
    }
    return instance;
  }
  // getInstance是自执行函数，定义的时候就执行了
})();
// 测试单体模式的实例
var a = getInstance("aa");
var b = getInstance("bb");
console.log(a === b); // true

// 常规模式创建弹层
var createWindow = function(){
  var div = document.createElement("div");
  div.innerHTML = "我是弹窗内容";
  div.style.display = 'none';
  document.body.appendChild('div');
  return div;
};
document.getElementById("Id").onclick = function(){
  // 点击后先创建一个div元素
  var win = createWindow();
  win.style.display = "block";
}

// 常规创建弹层时，若多次点击则创建多个，若通过移除再创建则造成性能浪费
// 单例模式创建弹层
var createWindow = (function () {
  var div
  return function(){
    if(!div){
      div = document.createElement('div')
      div.innerHTML = '这是弹层内容'
      div.style.display = 'none'
      document.body.appendChild(div)
    }
    return div
  }
})()
document.getElementById("Id").onclick = function(){
  // 点击后先创建一个div元素
  var win = createWindow();
  win.style.display = "block";
}

// 我们还可以再进一步抽离，比如如果此时要创建一个iframe元素，难道要重新写一遍上面的代码？
// 因此，虽然创建具体元素的代码不同，但单例模式的代码框架是相同的，如下
var getInstance = function(fn) {
  var result;
  return function(){
    // 有则返回，无则调用具体的创建代码
    return result || (result = fn.call(this,arguments));
  }
};
// 创建div
var createWindow = function(){
  var div = document.createElement("div");
  div.innerHTML = "我是弹窗内容";
  div.style.display = 'none';
  document.body.appendChild(div);
  return div;
};
// 创建iframe
var createIframe = function(){
  var iframe = document.createElement("iframe");
  document.body.appendChild(iframe);
  return iframe;
};
// 测试创建div
var createSingleDiv = getInstance(createWindow);
document.getElementById("Id").onclick = function(){
    var win = createSingleDiv();
    win.style.display = "block";
};
// 测试创建iframe
var createSingleIframe = getInstance(createIframe);
document.getElementById("Id").onclick = function(){
    var win = createSingleIframe();
    win.src = "http://cnblogs.com";
};
```

代理模式：代理是一个对象，它可以用来控制对本体对象的访问，它与本体对象实现了同样的接口，代理对象会把所有的调用方法传递给本体对象。
1. 代理对象可以代替本体被实例化，并使其可以被远程访问；
2. 它还可以把本体实例化推迟到真正需要的时候；对于实例化比较费时的本体对象，或者因为尺寸比较大以至于不用时不适于保存在内存中的本体，我们可以推迟实例化该对象；
比如现在京东ceo想送给奶茶妹一个礼物，但是呢假如该ceo不好意思送，或者由于工作忙没有时间送，那么这个时候他就想委托他的经纪人去做这件事，于是我们可以使用代理模式来编写如下代码：

```js
// 先申明一个奶茶妹对象
var TeaAndMilkGirl = function(name) {
  this.name = name;
};
// 这是京东ceo先生
var Ceo = function(girl) {
  this.girl = girl;
  // 送结婚礼物 给奶茶妹
  this.sendMarriageRing = function(ring) {
    console.log("Hi " + this.girl.name + ", ceo送你一个礼物：" + ring);
  }
};
// 京东ceo的经纪人是代理，来代替送
var ProxyObj = function(girl){
  this.girl = girl;
  // 经纪人代理送礼物给奶茶妹
  this.sendGift = function(gift) {
    // 代理模式负责本体对象实例化
    (new Ceo(this.girl)).sendMarriageRing(gift);
  }
};
// 初始化
var proxy = new ProxyObj(new TeaAndMilkGirl("奶茶妹"));
proxy.sendGift("结婚戒"); // Hi 奶茶妹, ceo送你一个礼物：结婚戒
```
上面的代理主要体现的是代理的特点1，即代理对象可以代替本体实例化，并使其可以远程控制。。。但特点2体现不明显，其实特点2就是**虚拟代理**，虚拟代理用于控制对那种创建开销很大的本体访问，他会把本体的实例化推迟到有方法调用的时候。其实类似事件循环，当事件有结果了，就去执行回调。。。

***模块化、`MV*`、***<br/>
历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。

在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。

ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。
```js
// CommonJS模块
let { stat, exists, readFile } = require('fs');

// 等同于
let _fs = require('fs');
let stat = _fs.stat;
let exists = _fs.exists;
let readfile = _fs.readfile;
```
上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，**因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”**。

**ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入**。
```js
// ES6模块
import { stat, exists, readFile } from 'fs';
```
上面代码的实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为**编译时加载或者静态加载**，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，**这也导致了没法引用 ES6 模块本身，因为它不是对象**。

由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。

***1、ES6 模块与 CommonJS 模块的差异***
- CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
- CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 <br/>

第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

***exports/import & module.exports/require区别***
参考：[exports与export的区别][exports&exportDiffUrl]
- require: node 和 es6 都支持的引入
- export / import : 只有es6 支持的导出引入
- module.exports / exports: 只有 node 支持的导出

***2、在ES模块里导入导出*** <br/>
1. export与export default均可用于导出常量、函数、文件、模块等
2. 在一个文件或模块中，export、import可以有多个，export default仅有一个
3. 通过export方式导出，在导入时要加{ }，export default则不需要
4. export能直接导出变量表达式，export default不行。

***MVC、MVVM***<br/>
mvvm模型，mvc模型诞生于早期，其实主要适用于view层逻辑比较简单，且大多是直接展示后台返回的代码模板，而现在的view层有大量的逻辑及频繁操作dom以及更新数据，若是再人为的操作，势必造成重复性劳作及性能问题，因此出现mvvm模型，vm自动同步v和m的变化，vue中每个实例可以理解为vm，vm.$el可以理解为v，而vm.$data可以理解为m，当v或m变化后，vm会自动同步二者。。。也就一定程度上避免了频繁的人为操作及性能问题

框架
框架分多种，每种类型的框架做的事情不尽相同，有点限于ui层面，有的限于模板层面，而vue和react提供状态到界面的映射及组件，但并没有http请求，路由，状态管理等，因此还需要配合第三方库使用。

像express和hapi.js是web框架，但vue和react也被常说成框架，但vue解释自己为js框架，而react为构建用户界面的js库，因此侧重点都是数据到界面的映射。。。而不是像express和hapi那样侧重api

#### ***网络模型及协议相关***
***网络模型***<br/>
1. **实体层**传输0和1；
2. **链路层**通过mac地址广播传输数据帧(标头和数据)；
3. **网络层**,路由器(DHCP)分发ip，配置子网掩码，ARP根据ip(域名解析)反解析mac地址；
4. **传输层**根据端口确定是哪个具体应用程序接收数据，udp和tcp为数据传输保驾护航，tcp三次握手四次挥手(效率低)；
5. **应用层**规定传输的数据的具体格式，如html,邮件等

**http1.1：**默认持久连接，但有队头阻塞问题(可同时发送多个，但响应则是挨个响应，若是第一个慢则会阻塞后面的)；

**http2而不是http2.0**，因为标准委员会不打算发布子版本，下一个版本直接就是http3

**http2特性：**请求头和体都是二进制；多工(服务端也可发送请求)且没队头阻塞；数据流，有标识且可设置优先级，还可关闭某个请求而不是整个tcp连接；头信息压缩

**Socket：**<br/>
参考：[什么是socket][whatIsSocketUrl]<br/>
我们深谙信息交流的价值，那网络中进程之间如何通信？如每天浏览器浏览网页时，浏览器的进程怎么与web服务器通信？。。。

本地进程间通信(IPC)有很多种方式，如下：
1. 消息传递（管道、FIFO、消息队列）
2. 同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）
3. 共享内存（匿名的和具名的）
4. 远程过程调用（Solaris门和Sun RPC）

在本地我们可以通过PID来标识唯一的进程，但在网络中则行不通。。。但TCP/IP协议族已经帮我们解决了，ip地址唯一标识网络中的主机，协议+端口则可以锁定主机中的应用程序。因此利用ip地址、协议、端口便可以标识网络中的进程，而网络中进程间的通信则利用这个标识与其他进程进行交互。

使用TCP/IP协议的应用程序通常采用应用编程接口：UNIX  BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用socket，而现在又是网络时代，网络中进程通信是无处不在，因此也可以说：一切皆socket。

既然网络中的进程是通过socket来通信的，那什么是socket呢？socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用`“打开open –> 读写write/read –> 关闭close”`模式来操作。因此**socket是该模式的一个实现方式，socket即是一种特殊的文件，一些socket函数就是对其进行的操作**，

![consultCache](/jsArt/assets/images/js-theory/protocol-relation.png)

再看下图，就可以发现其实`socket是应用层与TCP/IP协议族通信的中间软件抽象层`。在设计模式中，socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在socket接口后面，对用户来说，一组简单的接口就是全部，让socket去组织数据，以符合指定的协议。
![consultCache](/jsArt/assets/images/js-theory/socket-protocol.png)

其实，人们为计算机通信设计了若干接口，其中三个接口是通用的：
1. 套接字接口(socket interface)
2. 传输层接口(transport layer interface)
3. STREAM

套接字接口位于**操作系统与应用层之间**，如果应用程序想接入TCP/IP协议族提供的服务，就必须使用套接字接口中定义的指令，即socket编程：
![consultCache](/jsArt/assets/images/js-theory/socket-system.png)


**WebSocket：**一种在单个tcp连接上进行的全双工通讯的协议 <br/>
感觉webscoket和http2在双向通信方面很像，其实websocket只是基于http1.1建立的一个tcp长连接，进而可以双向传输二进制数据等。但http2只是对HTML、CSS等JS资源的传输方式进行了优化，并没有提供新的JS API，也不能用于实时传输消息。如果需要实时传输消息，现在还是需要SSE，WebSocket等

***DNS***<br/>
域名解析有递归和迭代，递归是本地dns服务器去查询，最后将结果返回给浏览器端。而迭代则是浏览器端主动去根，域服务器查询ip与域名的对应关系。<br/>

浏览器里也有dns缓存，`chrome://net-internals/#dns`即可查看，但好像只有清除
mac下hosts文件 `cat /etc/hosts`  /是根目录，~是用户家目录，因为一个系统下可以有多个用户

**NAT**(Network Address Translation 网络地址转换)<br/>
**UPnP**(Universal Plug and Play 通用即插即用) <br/>

**数据加密和https**<br/>
https无非是身披ssl的http，而ssl加密是发生在应用层与传输层之间，而抓包工具截获的是http传输的数据，也就是应用层的数据，因此通过安装证书可以看到明文信息。https通信保证了客户端到服务端的通信过程是安全的，但如果客户端本地有恶意软件，则无法阻止攻击。

银行系统一般还需要手机令牌，这些手机令牌是用来输入密码用的，也就是说，如果用系统的键盘输入密码，客户端的恶意软件可能拦截到密码，因此银行系统将输入密码的设备独立，这样就能阻止客户端上的恶意软件了。

综上：
1. 若只为保证客户端到服务端之间的通信安全，https就足够
2. 若想在客户端也不让用户看到明文，则需要配合另外aes和rsa加密

AES对称加密
1. 甲方选择某一种加密规则，对信息进行加密
2. 乙方使用同一种规则，对信息进行解密
由于加密和解密使用同样规则(即密钥)，因此如何传递密钥便是问题

RSA非对称加密
1. 乙方生成两把秘钥(公钥和私钥)，公钥是公开的，任何人都可以获得，私钥是保密的
2. 甲方获取乙方的公钥，然后用它对信息加密
3. 乙方得到加密后的信息，用私钥解密

加密过程：
1. 原生端有RSA的私钥和公钥，服务端有RSA的公钥和AES的密钥
2. 服务端用RSA的公钥对AES的密钥进行加密，然后传输给原生端
3. 原生端用RSA的私钥对来自服务端的加密传解析，得到AES的密钥
4. 这个AES的密钥再给h5端。（对于h5端需要与服务端直接交互的，暂时没做处理）

**数字签名**：私钥做签名，公钥做校验

***CDN延时***<br/>
CDN的全称是Content Delivery Network，即**内容分发网络**。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率(比如火车票代售点)。CDN的关键技术主要有内容存储和分发技术。

参考：[CDN的那些事][aboutCdnUrl] 、[CDN回源][aboutCdnHuiYuanUrl]<br/>

互联网数据中心（Internet Data Center）主要为互联网内容提供商（ICP）、企业、媒体和各类网站提供大规模、高质量、安全可靠的专业化服务器托管、空间租用、网络批发带宽以及ASP、EC等业务。

**CNAME：**当您拥有多个域名需要指向同一服务器IP，此时您就可以将一个域名做A记录指向服务器IP

***数据流模式***<br/>
http协议传输数据时可以选择`Transfer-Encoding: chunked`模式，也就是数据流模式，传输的数据是分块的，而不是一个完整的数据包。对于服务器处理慢的场合尤为适用。

***常见端口号***<br/>
TCP 21端口：FTP 文件传输服务
TCP 23端口：TELNET 终端仿真服务
TCP 25端口：SMTP 简单邮件传输服务
UDP 53端口：DNS 域名解析服务
TCP 80端口：HTTP 超文本传输服务
TCP 110端口：POP3 “邮局协议版本3”使用的端口
TCP 443端口：HTTPS 加密的超文本传输服务

***http协议状态码***<br/>
参考：[http状态码(mdn)][mdnHttpStatusCodesUrl]
http响应状态码指示特定http请求是否已成功完成，响应分为五类：信息响应，成功响应，重定向，客户端错误和服务端错误。
1. 信息响应
```js
100 // Continue 所有内容有效可继续请求，若请求已完成则忽略
101 // Switching Protocol 该代码是响应客户端的 Upgrade 标头发送的，并且指示服务器也正在切换的协议。
102 // Processing 此代码表示服务器已收到并正在处理请求，但没有响应可用
```

2. 成功响应
```js
200 // Ok 请求成功
204 // No Content服务器已成功处理请求，但不需要返回实体，并且希望返回更新了的元信息
```

3. 重定向
```js
301 // Moved Permanently 被请求的资源已永久移动到新位置(应该返回新的地址)
302 // Found 请求的资源临时从不同的 URI 响应请求
304 // Not Modified ，一般是针对get或put请求？
```

4. 客户端响应
```js
400 // Bad Request 语义或请求参数有误，请求无法被服务器理解
401 // Unanthorized 当前请求需要用户验证。
403 // Forbidden 服务器已经接受到请求，但拒绝执行它。服务器可以返回拒绝执行原因
404 // Not Found 请求所希望的资源未在服务器发现
405 // Method Not Allowed 响应返回允许的请求方式
408 // Request Timeout 请求超时，客户端没有在服务端预备等待的时间内完成一个请求的发送
```

5. 服务端响应
```js
500 // Internal Server Error 服务器遇到不知如何处理的情况
501 // Not Implemented 此请求方法不被服务器支持且无法被处理
502 // Bad Gateway 服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应
503 // Service Unavailable 服务器没有准备好处理请求(比如宕机或服务没起来)
504 // Gateway Timeout 当服务器作为网关，不能及时得到响应时返回此错误代码
505 // HTTP Version Not Supported 服务器不支持请求中使用的http版本
```

#### ***缓存相关***
***强制和协商缓存***<br/>
参考：[强制缓存与协商缓存][aboutForceCacheUrl]、[http缓存控制][aboutConsultCacheUrl]、[浏览器缓存浅析][browserCacheAnalyseUrl]

浏览器的缓存机制也就是我们常说的http缓存机制，是根据http报文的缓存标识进行。<br/>
第一次浏览器请求服务器，会根据响应报文中的http头的缓存标识，决定是否缓存结果，是则存储并将标识存入浏览器缓存中。

**注意：**<br/>
1. 浏览器每次发送请求，都会现在浏览器缓存中查找该请求的结果以及缓存标识
2. 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入到浏览器缓存中

根据是否向服务器重新发送http请求，将缓存分为强制和协商缓存:<br/>

**强制缓存：**根据缓存标识来决定缓存是否有效，若没有缓存标识和结果则直接请求服务器；若存在但失效则发起协商缓存请求过程；若存在且有效则直接返回；<br/>

标识：`Expires`是http1.0的产物，值为服务器返回该请求结果缓存的到期时间(绝对时间，若身处不同时区则不准确)；<br/>
`Cache-control`是http1.1的产物，有以下几种取值(多个取值可以逗号分隔)：<br/>
1. public 所有内容都将被缓存（客户端和代理服务器都可缓存）
2. private 所有内容只有对应的单个用户可以缓存，Cache-Control的默认取值
3. no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定
4. no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
5. max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效
当二者同时存在Cache-control优先级高。no-cache和no-store的区别是前者会缓存，但每次请求时依然先拿到缓存，只是不做验证，然后请求服务器，服务器来决定是否用缓存。

**Pragma**是http/1.0的产物，用于向后兼容还没有Cache-control的http/1.0的请求。
Pragma： no-cache 作用等同于Cache-control: no-cache

**优先级：** Pragma > Cache-control > Expires

内存缓存(内存缓存会将编译解析后的文件，直接存入该进程的内存中，一旦进程关闭则进程的内存就清空)和硬盘缓存

**协商缓存：**
强制缓存失效后，浏览器携带协商缓存标识向**服务器**发起请求，由服务器根据缓存标识来决定是否使用缓存的过程。<br/>

协商缓存生效，返回304过程：
![consultCache](/jsArt/assets/images/js-theory/consult-cache.png)
***务必注意：***协商缓存是先去请求服务器，判断是否更新，若没有更新则返回304码。然后再去浏览器缓存中拿数据,之所以发送条件请求是因为若条件成功，则可以省略传输响应体的时间，但连接还是需要建立的。如果不想304则可以？？？

同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，`其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高`。

强制缓存优先于协商缓存，若强制缓存生效则直接使用，若不生效则进行协商缓存，协商缓存由服务器确定是否使用。<br/>
总的过程如下：
![consultCache](/jsArt/assets/images/js-theory/cache-path.png)

***浏览器刷新行为***<br/>
1. 在URI输入栏中输入，然后回车/通过书签访问
2. F5（command + R）/点击工具栏中的刷新按钮/右键菜单重新加载
3. Ctrl + F5  /  command + shift + R

第二种刷新方式：让浏览器无论如何都发送一个http请求给Server，也就是说即使在强制缓存生效的情况下，这次发送的请求头里会有类似`Cache-Control: max-age=0`的字样，也就是chrome让强制缓存失效。。。当然如果有协商缓存标识，则依然会带上，因此这种情况可能会返回304状态码。

第三种刷新方式：这种就是强制刷新，不但需要重新发送请求，而且将协商缓存标识全部去掉。。。为了保证从服务器拿到的内容是全新的(防止中间代理服务器缓存)，还需要添加一些http headers如`Cache-Control: no-cache、Pragma: no-cache`，这样就能从服务端获取到最新的数据。

#### ***版本控制相关***
前端所谓的版本控制，一般说的是前端资源(比如css,js,img等)的版本控制和代码的版本控制系统(git，svn等)；

**前端资源版本管理**<br/>
前端资源的版本控制主要是解决缓存问题的。。。例如：文件内容修改了，但名字没有改，浏览器不强制刷新则访问的则很可能是缓存里的内容。如果每次修改都给文件添加一个版本号，势必繁琐(为了统一版本，每次修改一个文件都需要将其他所有文件的版本号更新)。既然版本号不易控制，若根据文件内容生成hash值，将版本号改为hash值，会稍微好一些。但对于大型应用，资源文件一般部署在cdn上，主文件部署在服务器上，那二者谁先发布呢？如下
```js
<link rel="stylesheet" href="a.css?v=e0279"></link>
<script src="a.js?v=abb35"></script>
```
1. 先发资源文件，之前的资源文件被覆盖，在主文件发布成功之前，没有缓存或强制刷新的用户，会导致页面错乱
2. 先发主文件，在资源文件发布成功之前，用户访问到得资源文件都是旧的

因为上面文件的url只是query不同，因此相当于同一个文件，所以是覆盖式。。。如果将文件名改了，则就不存在覆盖的问题了，这样新版和旧版资源文件就同时存在，于是代码变成如下：
```js
<link rel="stylesheet" href="a.e0279.css"></link>
<script src="a.e0279.js"></script>
```
此时先发布资源文件，成功后再发布主文件就没有问题了。

而如何生成这个hash就是构建的工作了，主要有`hash、chunkhash、contenthash`三种：
1. hash与整个项目构建相关，一个文件改变则所有文件都变
2. chunkhash是根据入口文件进行解析、构建对应的chunk的，生成对应的hash值
3. contenthash是针对文件内容级别，只有文件内容改变才会改变
之所以出现contenthash，是因为chunkhash有个问题，比如a文件修改了，则与其关联(如引用)的相关文件的hash值也会改变，也就失去缓存的目的了，如下：
![dpr&ppi](/jsArt/assets/images/js-theory/chunk-contenthash.png)

**代码版本管理**<br/>
代码版本管理主要分集中式(svn)和分布式(git)，那二者什么区别呢？

集中式：版本库是集中存放在中央服务器的，干活的时候先联网拉下代码，然后修改，改完再推送到服务器。没有网络无法工作，好比图书馆，不开馆没法借书。主要问题就是严重依赖网络

分布式：不需要联网没有中央服务器，每人电脑上的都是一个完整的版本库。不联网时如何多人协作,其实网络说的是外网，局域网还是需要的，相互之间的修改就可以通过局域网相互之间推送。。。其实即使分布式，我们也很少相互之间推送代码，而是将代码推送到一台充当“中央服务器”的地方，这里的“中央服务器”只是方便大家相互之间交流而已,以防止同事请假，电脑故障等情况。。。

从上面看感觉分布式比集中式的优势就是不需要联网，其实作为分布式的代表git，在分支管理上远胜于svn!!!


#### ***编码相关***
编码其实就是一种数据格式转换为另外一种格式的过程。

**ASCII码**计算机最终识别的是二进制数据格式，一个字节八位，也就是256种状态，每种状态可以用一个字符表示。而美国制定的英文字符与二进制数的映射就是ASCII码，一直用到现在。

在ASCII中，用7个二进制位表示一个打印或不可打印的字符，共表示128个字符，其中95个可打印或显示的字符，其他的则为不可打印或显示的字符。所谓不可打印是指那些禁止在报纸，电视或其他媒体上出现的符号，这些符号被用来表示一些特定的功能，如回车，换行，制表符等。。。比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号，只占用了一个字节的后面7位，最前面的一位统一规定为0。

英文字符7位就可以表示完全，但对于汉语而言就远远不够了，汉字大概就是10万+，两个字节才表示65535种，因此汉语还有四字节表示一个字。也就是中国的国标GB

但世界各国的编码都不一样，有么有一种方式可以统一呢，这就是**unicode码**，虽然unicode码解决了是否统一的问题，但数据在网络上传输时是需要占带宽的，因此如何合理存储这些编码就尤为重要，因为一个英文字符用unicode来表示势必占更多内存。。。因此就出现了**utf-8**，是unicode编码的实现方式之一。对于部分编码，存储时还涉及`Little endian 和Big endian-`问题，也就是字节存储的先后顺序问题。

**base64编码**Base64是一种基于64个可打印字符来表示二进制数据的表示方法。由于2的6次方等于64，所以每6个二进制位为一个单元，对应某个可打印字符。三个字节有24个二进制位（比特位），对应于4个Base64单元，即3个字节对应的符号可以用4个可打印字符表示。之所以诞生，因为早期http协议等都只能传输ascii格式，但有些数据(比如图片)转化为二进制后，超过了ascii表示的范围。

**encodeURI()**函数通过将特定字符的每个实例替换为一个、两个、三或四转义序列来对统一资源标识符 (URI) 进行编码 。因此这些系列主要是对URI进行编码

中文域名（需要中文转码成ascii码）

#### ***构建相关***
***部署脚本***<br/>

#### ***性能优化相关***
***前端优化性能清单***<br/>
参考：[前端优化性能清单][frontEndOptimizeUrl]

***vue性能优化***<br/>
参考：[vue性能优化][vueOptimizeUrl]、[vue3.0优化(尤大)][vue3.0OptimizeUrl]

***css性能优化***<br/>
参考：[css性能优化的8个技巧][eightCssOptimizeUrl]

#### ***IDE相关***


#### ***持续集成***
***Jenkins***<br/>
在项目的早期，测试环境需要通过jenkins来部署，而线上环境需要将项目生成的dist目录发送给运维手动上线。

持续集成
在说jenkins时，需要先说说持续集成，持续集成指的是，频繁的(一天多次)将代码集成到主干，它主要好处如下：
1. 快速发现错误。每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易
2. 防止分支大幅偏离主分支。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成
持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。持续集成不能消除bug，而是让他们非常容易发现和改正

持续集成又分持续交互和持续部署
持续交互：指的是频繁的将软件的新版本交付给代码质量团队评审。评审通过就手动部署到测试或生产环境
持续部署：指的是将评审合格的代码，自动部署到测试或生产环境。

流程：
1. 开发提交代码至仓库
2. 仓库对commit操作配置了钩子(hook)，只要有新代码提交，就会触发hook
3. 然后就会触发jenkins的自动构建，也就是通过配置的脚本，拉取最新代码，安装依赖，配置各种资源，启动服务等。而这里的构建工具就是jenkins
4. jenkins是图形化界面配置，可以自动构建，还可以手动构建。

jenkins支持构建，部署，自动化

***Iaas,Paas,Saas***<br/>
越来越多的软件，开始采用云服务，但云服务只是一个统称，可以分为三大类：
1. Iaas基础设施服务(Infrastructure as a service)
2. Paas平台服务(Platform as a service)
3. Saas软件服务(Software as a service)

**Saas是软件的开发、管理、部署都交给第三方，不需要关心技术问题，可以直接拿来用**。普通用户接触到的互联网服务几乎都是Saas；

**Paas提供软件部署平台(runtime)，抽象掉了硬件和操作系统细节，可以无缝地扩展。开发者只需要关注自己的业务逻辑，不需要关注底层**。

**Iaas是云服务的最底层，主要提供一些基础资源**，他与Paas的区别是，用户需要自己控制底层，实现基础设施的使用逻辑。

打个通俗的比方：如果你是网站站长，想建立一个网站。不采用云服务，则你需要：买服务器，安装服务器软件，编写网站程序。。。

若采用Iaas服务，则不需要购买服务器<br/>
若采用Paas服务，则不需要购买服务器，也不需要安装服务器软件<br/>
若采用Saas服务，则什么都不需要购买或安装，只需要专心负责运营即可<br/>

#### ***服务器相关***
***express.js与hapi.js***<br/>
1. 都是为在node环境中构建 HTTP 服务器提供方便的 API。 也就是说，比单独使用较低级别的原生 http 模块更方便。 Http 模块可以做任何我们想做的事情，但是用它来编写应用程序是很乏味的。
2. 他们都使用了高级web框架中已有的功能：路由，插件，认证模块，处理函数等(比如：当比配到一个页面的路由时，会有对应的处理函数进行处理)
3. express是非常小的，只是在http模块上提供一个很小的api，多数功能都可以通过额外的中间件来实现（中间件类似过滤器，在请求到达处理程序之前通过他们处理）。而hapi.js具有丰富的特性集，通常通过配置选项，而不需要编写代码。具体的差异可以对比二者的api文档
4. hapi具有请求生命周期并提供扩展点，与中间件类似，但在生命周期中存在多个已定义的点
5. 沃尔玛创建了hapi并停止express的原因之一，是因为很难将一个express应用拆分成单独的部分，让不同的团队成员安全的工作。
6. 一个插件就像一个子应用程序，你可以做任何可以在hapi.js应用程序里的操作，比如添加路由，扩展等。在一个插件系统里，你可以确定你没有破坏应用的其他部分，因为注册的顺序并不重要，你不能创建冲突的路线，你可以将这些插件组合到一个服务器中并进行部署。
7. 因为express只能提供很少的开箱即用功能，所以当你需要向项目中添加任何内容时，需要考虑外部因素。很多时候在使用hapi时，你需要的特性要么是内置的，要么是由核心团队创建的模块。
8. 极简主义虽然听起来不错，但如果你正在构建一个严谨的生产应用程序，hapi.js内置的很多东西或许是你需要的。hapi.js是由沃尔玛团队设计，并主要用于黑色星期五的交通，因此安全性和稳定性备受关注。也因此框架做了很多额外的事情，比如限制传入有效负载的大小，以防止耗尽进程内存。它还有一些选项，如最大事件循环延迟，最大rss内存使用和最大v8堆带下，超过这个时间，你的服务器将响应503超时，而不是崩溃。

nodemon(检测目录中的文件改动并自动重新启动应用程序)
1，代码html修改后，webpack不自动编译，需要重启服务并刷新页面。页面不会自动更新(需要重启服务并刷新页面)
2，修改js和css文件，webpack自动编译，不要重启服务，只需要刷新页面就好。

***Webpack***<br/>
该工具是打包工具，自动分拣js,css,html到不同的文件内，并通过生成的manifest或runtime来自动加载每个页面对应的资源文件。


#### ***git相关***

#### ***linux相关***
***unix、linux、mac相爱相杀***<br/>
参考：[unix、linux、mac科普篇][unix&Linux&MacStoryUrl]、[Linux vs Unix][unix&LinuxDiffUrl]

linux是一个采用了unix的设计思想，初始行为表现与unix相同的操作系统，但Linux中的源码并未有任何出自Unix。Linux符合一切皆文件的思想，其中**读写操作都是处理文件描述符**，无论是文件描述符后面的是真正要打开的文件，还是进程间通信的套接字，对于用户而言都是**操作**文件描述符。。。

***mac常用命令***<br/>

***常用编辑器***<br/>



<!-- 设备相关 -->
[cssPxDevicePxUrl]: https://github.com/jawil/blog/issues/21
[androidViewportWidthSizeUrl]: http://viewportsizes.com
[taoBaoFlexibleUrl]: https://www.kancloud.cn/chandler/web_app/353540
[commonRegexUrl]: https://juejin.im/post/5b96a8e2e51d450e6a2de115
[allRegexUnitUrl]: http://tool.oschina.net/uploads/apidocs/jquery/regexp.html
[mdnRegexUrl]: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions


<!-- CSS相关 -->
[marginCollapsingUrl]: https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing
[w3choolCssSelectorUrl]: http://www.w3school.com.cn/cssref/css_selectors.ASP
[frontEndDatabaseUrl]: https://leohxj.gitbooks.io/front-end-database/index.html
[tenDesignStylesUrl]: https://juejin.im/entry/58c280b1da2f600d8725b887

<!--  -->
[mdnHttpStatusCodesUrl]: https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status
[html5MdnUrl]: https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/HTML5
[html5&css3NewFeatureUrl]: https://yq.aliyun.com/articles/610581
[indexedDB(ruanyifeng)]: http://www.ruanyifeng.com/blog/2018/07/indexeddb.html
[whatIsSocketUrl]: http://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html
[frontEndOptimizeUrl]: https://juejin.im/post/5a966bd16fb9a0635172a50a
[vueOptimizeUrl]: https://juejin.im/post/5b960fcae51d450e9d645c5f
[vue3.0OptimizeUrl]: https://yuccie.github.io/jsArt/2018/11/vue3/
[eightCssOptimizeUrl]: https://juejin.im/post/5b6133a351882519d346853f

<!-- linux相关 -->
[unix&Linux&MacStoryUrl]: https://blog.csdn.net/zhanghow/article/details/53542397
[unix&LinuxDiffUrl]: https://news.mydrivers.com/1/580/580273.htm


[aboutCdnUrl]: http://genie88.github.io/2015/11/03/talk-about-content-delivery-network-and-caches/
[aboutCdnHuiYuanUrl]: https://juejin.im/post/5af46498f265da0b8d41f6a3
[aboutConsultCacheUrl]: https://imweb.io/topic/5795dcb6fb312541492eda8c
[aboutForceCacheUrl]: https://juejin.im/entry/5ad86c16f265da505a77dca4
[browserCacheAnalyseUrl]: https://github.com/zhengweikeng/blog/issues/5
[exports&exportDiffUrl]: https://github.com/aooy/blog/issues/5