---
layout: post
title: need do
date: Wed Nov 14 2018 19:33:18 GMT+0800 (中国标准时间)
---


### 常见的一些问题及相关参考链接

如果动画正在执行时，数据发生更新应该如何处理？为看起来流畅，应该先等动画执行完，再更新数据，再开始动画，但又如何知道什么时候结束动画？如果不这样有没有其他方式？


以后不能说不知道，先思考一下如何才能得到？不会先留着

1. 支付逻辑，
2. 埋点逻辑
3. docker
4. 小程序
5. 部署脚本
6. 框架
7. cas单点登录
8. vue源码
9. ts
10. jenkins
11. 数据结构及算法
13. 微信sdk,授权，支付，分享
14. 唤起app
15. 线程，进程，微任务，宏任务
16. Socket协议



常用端口号》》》<br/>
常用的端口号



#### bfc

#### 中文域名（需要中文转码成asicc码）

#### 几个常用的正则
邮箱，手机号等等

#### 
邮箱，手机号等等

#### 
linux mac


#### ***HTML相关***
***viewport***
```html
<meta name="viewport" content="width=device-width,initial-scale=1"></meta>
```

#### ***CSS相关***
***margin collapsing***<br/>
**块级元素**的**上外边距和下外边距**有时会合并(或折叠)为一个外边距，其**大小取其中大者**，可理解为外边距折叠或外边距合并，**浮动元素和绝对定位元素的外边距不会折叠**

几种折叠场景：
1. 相邻元素之间（除非后面的元素清除之前的浮动）
2. 父元素与其第一个或最后一个子元素之间
3. 空的块级元素

其实说到底，只要margin-top和margin-bottom之间没有**一些东西**隔开，就会发生合并。。。而这里的**一些东西**可以是：边框、内边距、行内内容、height、min-height 等。<br/>
参考：[margin合并(mdn)][marginCollapsingUrl]


***BFC(Block Formatting Context)***<br/>
块格式化上下文是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。<br/>





#### ***Javascript相关***
***常用算法***
```js
// 1、冒泡排序
function bubleSort(arr) {
  if(!arr) return
  let arrLen = arr.length
  for(let i = 1; i < arrLen; i++){
    for(let j = 0; j < arrLen - i; j++){
      if(arr[j] > arr[j+1]){
        [arr[j+1],arr[j]] = [arr[j],arr[j+1]]
      }
      // 还可以这样,
      // arr[j] > arr[j+1] && ([arr[j+1], arr[j]] = [arr[j], arr[j+1]])
    }
  }
  return arr
}

// 2、数组去重
// 2.1，利用forEach，将数组的元素取出来作为对象的key，然后赋予任意值，最后获取key列表
var uniqueArr = arr => {
  let obj = {}
  arr.forEach((val) => {
    obj[val] = 0
  })
  // 注意，返回的是可枚举的字符串数组
  return Object.keys(obj)
}

// 2.2，filter，indexOf只会返回第一个匹配数据的index
var uniqueArr = arr => {
  // Array.prototype.filter(callback(element[, index[, array]])[, thisArg])
  // 注意可选参数的意义；thisArg为执行callback时this值
  return arr.filter((ele, index, array) => {
    return index === array.indexOf(ele)
  })
}

// 2.3，set
var uniqueArr = arr => {
  // 注意只适用于数组为基本数据类型的
  return [...new Set(arr)]
}

// 2.4，reduce
// Array.prototype.reduce(callback(accumulator,currentValue[, currentIndex[, array]])[, initialValue])
// accumulator是累计器最终的值，若initialValue没传则默认取数组第一项，currentValue则自动为第二项
// 下面给累加器传的值是一个对象，相当于2.1方法的另外一种方式
var uniqueArr = arr.reduce((map,item) => {
  map[itme] = 0
  return map
}, {})
Object.keys(uniqueArr)

// 3、字符串反转
var reverseString = str => {
  return [...str].reverse().join('')
}
```

***常用函数***
```js
// 防抖
// 小于设置的interval时间间隔都不会触发，因为clearTimeout了
function debounce(fn, interval = 300) {
  let timeout = null
  return function () {
    clearTimeout(timeout)
    timeout = setTimeout(() => {
      fn.apply(this,arguments)
    },interval)
  }
}
window.onresize = debounce(()=>{console.log('resizing')},500)
window.addEventListener('resize',debounce(()=>{console.log('resizing')},500))

// 节流
function throttle(fn, interval) {
  // let canRun = null // 注意这里canRun不是null
  let canRun = true
  return function () {
    // !canRun && return // 这样写错误
    if(!canRun) return
    canRun = false
    setTimeout(()=>{
      fn.apply(this, arguments)
      canRun = true
    },interval)
  }
}
window.onresize = throttle(()=>{console.log('resizing')})
//这里的e就是resize事件，但这里打印的是[object Event],因为``里面是字符串
window.onresize = throttle((e)=>{console.log('resizing',`e is ${e}`)}) 
```

***基于对象与OOP(面向对象)***<br/>
js的核心是支持面向对象，但准确来说是基于对象
>oop（object oriented programming）面向对象编程是用抽象方式创建基于现实世界模型的一种编程方式。

基于对象，就是一个工程师建了一栋房子，然后其它的工程师按照这个房子的样子去建造其它的房子<br/>
面向对象，就是一个工程师再图纸上设计出一栋房子的样子，然后其它工程师按照这个图纸的设计去建造房子<br/>

也就是说:<br/>
基于对象是先有一个具体的对象，然后在这个对象的基础上创建新的对象<br/>
面向对象就是先有一个抽象的对象描述，然后以此为蓝本构建具体对象<br/>

一般的面向对象语言 中的类的概念 都是 一个 抽象的声明，当 new 出来一个对象的时候，就是依据 类的声明给造出来的，就像是模子里面刻出来的。<br/>
javascript是基于对象的，那么它所有的对象都是从原型对象继承而来，和原型模式大概相似，Javascript的动态特性，可以随时的给对象的原型添加方法或属性，然后new出来的对象就有了。

但作为es6的class，其实并不能说是面向对象，可以将class看成一个语法糖，新的class写法只是让对象原型的写法更加清晰，**更像面向对象编程的语法**而已，如下：
```js
// 构造函数
function Point (x) {
  this.x = x
}
// 给原型添加属性
Point.prototype.toString = function () {
  return `this.x is ${this.x}`
}

// class写法
class Point {
  // 构造函数
  constructor (x) {
    this.x = x
  }
  // 直接添加方法
  toString () {
    return `this.x is ${this.x}`
  }
}
// 实例化
var newPoint = new Point('test')
newPoint.toString() // this.x is test

// super关键字是用于访问和调用一个对象的父对象上的函数

super([arguments]) // 调用父类或父对象的构造函数，参数作为构造函数的参数传入
super.functionOnParent([arguments]) // 指定父类或父对象上的方法并调用

// class实现继承是通过 extends
class colorPoint extends Point {
  constructor (x, color) {
    super(x)
    this.color = color
  }
  toString () {
    return `this.color is ${this.color} & ${super.toString()}`
  }
}
```

#### ***网络模型及协议相关***
***网络模型***<br/>
1. **实体层**传输0和1；
2. **链路层**通过mac地址广播传输数据帧(标头和数据)；
3. **网络层**,路由器(DHCP)分发ip，配置子网掩码，ARP根据ip(域名解析)反解析mac地址；
4. **传输层**根据端口确定是哪个具体应用程序接收数据，udp和tcp为数据传输保驾护航，tcp三次握手四次挥手(效率低)；
5. **应用层**规定传输的数据的具体格式，如html,邮件等

**http1.1：**默认持久连接，但有队头阻塞问题(可同时发送多个，但响应则是挨个响应，若是第一个慢则会阻塞后面的)；
http2而不是http2.0，因为标准委员会不打算发布子版本，下一个版本直接就是http3

**http2特性：**请求头和体都是二进制；多工(服务端也可发送请求)且没队头阻塞；数据流，有标识且可设置优先级，还可关闭某个请求而不是整个tcp连接；头信息压缩

**WebSocket：**一种在单个tcp连接上进行的全双工通讯的协议 <br/>
感觉webscoket和http2在双向通信方面很像，其实websocket只是基于http1.1建立的一个tcp长连接，进而可以双向传输二进制数据等。但http2只是对HTML、CSS等JS资源的传输方式进行了优化，并没有提供新的JS API，也不能用于实时传输消息。如果需要实时传输消息，现在还是需要SSE，WebSocket等

***DNS***<br/>
域名解析有递归和迭代，递归是本地dns服务器去查询，最后将结果返回给浏览器端。而迭代则是浏览器端主动去根，域服务器查询ip与域名的对应关系。<br/>

浏览器里也有dns缓存，`chrome://net-internals/#dns`即可查看，但好像只有清除
mac下hosts文件 `cat /etc/hosts`  /是根目录，~是用户家目录，因为一个系统下可以有多个用户

**NAT**(Network Address Translation 网络地址转换)<br/>
**UPnP**(Universal Plug and Play 通用即插即用) <br/>

**rsa加密**：公钥加密私钥解密<br/>
**数字签名**：私钥做签名，公钥做校验

**数据加密和https**<br/>
https无非是身披ssl的http，而ssl加密是发生在应用层与传输层之间，而抓包工具截获的是http传输的数据，也就是应用层的数据，因此通过安装证书可以看到明文信息。https通信保证了客户端到服务端的通信过程是安全的，但如果客户端本地有恶意软件，则无法阻止攻击。

银行系统一般还需要手机令牌，这些手机令牌是用来输入密码用的，也就是说，如果用系统的键盘输入密码，客户端的恶意软件可能拦截到密码，因此银行系统将输入密码的设备独立，这样就能阻止客户端上的恶意软件了。

***CDN延时***<br/>
CDN的全称是Content Delivery Network，即**内容分发网络**。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率(比如火车票代售点)。CDN的关键技术主要有内容存储和分发技术。

参考：[CDN的那些事][aboutCdnUrl] 、[CDN回源][aboutCdnHuiYuanUrl]<br/>

互联网数据中心（Internet Data Center）主要为互联网内容提供商（ICP）、企业、媒体和各类网站提供大规模、高质量、安全可靠的专业化服务器托管、空间租用、网络批发带宽以及ASP、EC等业务。

**CNAME：**当您拥有多个域名需要指向同一服务器IP，此时您就可以将一个域名做A记录指向服务器IP

***数据流模式***<br/>
http协议传输数据时可以选择`Transfer-Encoding: chunked`模式，也就是数据流模式，传输的数据是分块的，而不是一个完整的数据包。对于服务器处理慢的场合尤为适用。


#### ***缓存相关***
***强制和协商缓存***<br/>
参考：[强制缓存与协商缓存][aboutForceCacheUrl]、[http缓存控制][aboutConsultCacheUrl]、[浏览器缓存浅析][browserCacheAnalyseUrl]

浏览器的缓存机制也就是我们常说的http缓存机制，是根据http报文的缓存标识进行。<br/>
第一次浏览器请求服务器，会根据响应报文中的http头的缓存标识，决定是否缓存结果，是则存储并将标识存入浏览器缓存中。

**注意：**<br/>
1. 浏览器每次发送请求，都会现在浏览器缓存中查找该请求的结果以及缓存标识
2. 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入到浏览器缓存中

根据是否向服务器重新发送http请求，将缓存分为强制和协商缓存:<br/>

**强制缓存：**根据缓存标识来决定缓存是否有效，若没有缓存标识和结果则直接请求服务器；若存在但失效则发起协商缓存请求过程；若存在且有效则直接返回；<br/>

标识：`Expires`是http1.0的产物，值为服务器返回该请求结果缓存的到期时间(绝对时间，若身处不同时区则不准确)；<br/>
`Cache-control`是http1.1的产物，有以下几种取值(多个取值可以逗号分隔)：<br/>
1. public 所有内容都将被缓存（客户端和代理服务器都可缓存）
2. private 所有内容只有对应的单个用户可以缓存，Cache-Control的默认取值
3. no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定
4. no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
5. max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效
当二者同时存在Cache-control优先级高。no-cache和no-store的区别是前者会缓存，但每次请求时依然先拿到缓存，只是不做验证，然后请求服务器，服务器来决定是否用缓存。

**Pragma**是http/1.0的产物，用于向后兼容还没有Cache-control的http/1.0的请求。
Pragma： no-cache 作用等同于Cache-control: no-cache

内存缓存(内存缓存会将编译解析后的文件，直接存入该进程的内存中，一旦进程关闭则进程的内存就清空)和硬盘缓存

**协商缓存：**
强制缓存失效后，浏览器携带协商缓存标识向**服务器**发起请求，由服务器根据缓存标识来决定是否使用缓存的过程。<br/>

协商缓存生效，返回304过程：
![consultCache](/jsArt/assets/images/js-theory/consult-cache.png)
***务必注意：***协商缓存是先去请求服务器，判断是否更新，若没有更新则返回304码。然后再去浏览器缓存中拿数据,之所以发送条件请求是因为若条件成功，则可以省略传输响应体的时间，但连接还是需要建立的。如果不想304则可以？？？

同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，`其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高`。

强制缓存优先于协商缓存，若强制缓存生效则直接使用，若不生效则进行协商缓存，协商缓存由服务器确定是否使用。<br/>
总的过程如下：
![consultCache](/jsArt/assets/images/js-theory/cache-path.png)


#### ***编码相关***
编码其实就是一种数据格式转换为另外一种格式的过程。

**ASCII码**计算机最终识别的是二进制数据格式，一个字节八位，也就是256种状态，每种状态可以用一个字符表示。而美国制定的英文字符与二进制数的映射就是ASCII码，一直用到现在。

在ASCII中，用7个二进制位表示一个打印或不可打印的字符，共表示128个字符，其中95个可打印或显示的字符，其他的则为不可打印或显示的字符。所谓不可打印是指那些禁止在报纸，电视或其他媒体上出现的符号，这些符号被用来表示一些特定的功能，如回车，换行，制表符等。。。比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号，只占用了一个字节的后面7位，最前面的一位统一规定为0。

英文字符7位就可以表示完全，但对于汉语而言就远远不够了，汉字大概就是10万+，两个字节才表示65535种，因此汉语还有四字节表示一个字。也就是中国的国标GB

但世界各国的编码都不一样，有么有一种方式可以统一呢，这就是**unicode码**，虽然unicode码解决了是否统一的问题，但数据在网络上传输时是需要占带宽的，因此如何合理存储这些编码就尤为重要，因为一个英文字符用unicode来表示势必占更多内存。。。因此就出现了**utf-8**，是unicode编码的实现方式之一。对于部分编码，存储时还涉及`Little endian 和Big endian-`问题，也就是字节存储的先后顺序问题。

**base64编码**Base64是一种基于64个可打印字符来表示二进制数据的表示方法。由于2的6次方等于64，所以每6个二进制位为一个单元，对应某个可打印字符。三个字节有24个二进制位（比特位），对应于4个Base64单元，即3个字节对应的符号可以用4个可打印字符表示。之所以诞生，因为早期http协议等都只能传输ascii格式，但有些数据(比如图片)转化为二进制后，超过了ascii表示的范围。

**encodeURI()**函数通过将特定字符的每个实例替换为一个、两个、三或四转义序列来对统一资源标识符 (URI) 进行编码 。因此这些系列主要是对URI进行编码

#### ***构建工具相关***

#### ***IDE相关***

#### ***服务器相关***

#### ***git相关***

#### ***linux相关***
***unix、linux、mac相爱相杀***<br/>
参考：[unix、linux、mac科普篇][unix&Linux&MacStoryUrl]、[Linux vs Unix][unix&LinuxDiffUrl]

linux是一个采用了unix的设计思想，初始行为表现与unix相同的操作系统，但Linux中的源码并未有任何出自Unix。Linux符合一切皆文件的思想，其中**读写操作都是处理文件描述符**，无论是文件描述符后面的是真正要打开的文件，还是进程间通信的套接字，对于用户而言都是**操作**文件描述符。。。

***mac常用命令***<br/>

***常用编辑器***<br/>



<!-- CSS相关 -->
[marginCollapsingUrl]: https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing


<!-- linux相关 -->
[unix&Linux&MacStoryUrl]: https://blog.csdn.net/zhanghow/article/details/53542397
[unix&LinuxDiffUrl]: https://news.mydrivers.com/1/580/580273.htm




[aboutCdnUrl]: http://genie88.github.io/2015/11/03/talk-about-content-delivery-network-and-caches/
[aboutCdnHuiYuanUrl]: https://juejin.im/post/5af46498f265da0b8d41f6a3
[aboutConsultCacheUrl]: https://imweb.io/topic/5795dcb6fb312541492eda8c
[aboutForceCacheUrl]: https://juejin.im/entry/5ad86c16f265da505a77dca4
[browserCacheAnalyseUrl]: https://github.com/zhengweikeng/blog/issues/5